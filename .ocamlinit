open Unfoldings;;
open Unfoldings.Branching_process;;
open Unfoldings.Product_pretrinet;;
open Unfoldings.Unfold;;
open Unfoldings.Labelled_place;;

let sts = ["s1";"s3";"r5";"r5";"s3";"r5"]
let ps = label_states sts 0;;
let lbl_as st = PlaceSet.elements (places_labeled_as st ps);;

(*
open Examples.N1;;
let p = n1;;
*)
open Examples.Prod;;
let p = n;;

let list_of_placeset = PlaceSet.elements;;
let list_of_transset = TransSet.elements;;

open Product_transition;;

let n0 = unfold_init p;;

(* this step adds event e2, two output places and four new flows to n0 *)
let n1s = unfold_1 n0 1 p sl_compare;;
assert (List.length n1s = 3);;
let n1 = let _,n = List.hd n1s in n;;

let n2s = unfold_1 n1 2 p sl_compare;;
assert (List.length n2s = 1);;
let n2 = let _,n =  List.nth n2s 0 in n;;

let n3s = unfold_1 n2 3 p sl_compare;;
assert (List.length n3s = 1);;
let n3 = let _,n =  List.nth n3s 0 in n;;

let n4s = unfold_1 n3 4 p sl_compare;;
assert (List.length n4s = 2);;
let n4 = let _,n =  List.nth n4s 1 in n;;

let n5s = unfold_1 n4 5 p sl_compare;;
assert (List.length n5s = 2);;
let n5 = let _,n =  List.nth n5s 0 in n;;

let n6s = unfold_1 n5 6 p sl_compare;;
assert (List.length n6s = 3);;
let n6 = let _,n =  List.nth n6s 0 in n;;
